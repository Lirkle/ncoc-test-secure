/* 2D Planner Pro - чистый Canvas, без зависимостей
   Возможности:
   - Стены: полилиния, толщина, замыкание, редактирование узлов
   - Двери/окна: вставка в стену как "проем" с шириной, смещением, ориентацией
   - Комнаты: полигон, авто-площадь, заливка, подпись
   - Мебель: прямоугольники с вращением, ручки scale/rotate, z-order
   - Размеры: линейные размеры (между точками), отображение в метрах
   - Привязки: сетка, узлы, орто (90 градусов), конец/середина/перпендикуляр к стене
   - Камера: пан/зум
   - Выбор: одиночный, мульти (Shift), рамка
   - Undo/Redo: стек снапшотов
   - Копировать/вставить, дубликат
   - Экспорт PNG, импорт/экспорт JSON
   - Автосейв localStorage
*/

(() => {
  "use strict";

  // ---------- Utils ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };
  const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);
  const rad = (deg) => deg * Math.PI / 180;
  const deg = (r) => r * 180 / Math.PI;
  const roundTo = (v, step) => Math.round(v / step) * step;
  const deepCopy = (o) => JSON.parse(JSON.stringify(o));
  const uid = (() => { let i = 1; return () => `${Date.now().toString(36)}_${(i++).toString(36)}`; })();

  function pointToSegmentDistance(px, py, ax, ay, bx, by) {
    const vx = bx - ax, vy = by - ay;
    const wx = px - ax, wy = py - ay;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px - ax, py - ay);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px - bx, py - by);
    const t = c1 / c2;
    const projx = ax + t*vx, projy = ay + t*vy;
    return Math.hypot(px - projx, py - projy);
  }

  function projectPointToSegment(px, py, ax, ay, bx, by) {
    const vx = bx - ax, vy = by - ay;
    const c2 = vx*vx + vy*vy;
    if (c2 < 1e-9) return {x: ax, y: ay, t: 0};
    const t = ((px - ax)*vx + (py - ay)*vy) / c2;
    const tt = clamp(t, 0, 1);
    return {x: ax + tt*vx, y: ay + tt*vy, t: tt};
  }

  // ---------- DOM ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const statusEl = document.getElementById("status");
  const propsEl = document.getElementById("props");
  const layersEl = document.getElementById("layers");
  const libEl = document.getElementById("lib");

  const toolButtons = [...document.querySelectorAll(".btn.tool")];
  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const delBtn = document.getElementById("delBtn");
  const clearBtn = document.getElementById("clearBtn");
  const saveBtn = document.getElementById("saveBtn");
  const loadBtn = document.getElementById("loadBtn");
  const loadFile = document.getElementById("loadFile");
  const exportBtn = document.getElementById("exportBtn");

  const snapGridEl = document.getElementById("snapGrid");
  const snapGeomEl = document.getElementById("snapGeom");
  const snapOrthoEl = document.getElementById("snapOrtho");
  const showDimsEl = document.getElementById("showDims");
  const gridCmEl = document.getElementById("gridCm");
  const pxPerMEl = document.getElementById("pxPerM");

  // ---------- State ----------
  const STORAGE_KEY = "planner_pro_autosave_v1";

  const state = {
    tool: "select",
    snapGrid: true,
    snapGeom: true,
    snapOrtho: true,
    showDims: true,
    gridCm: 50,
    pxPerM: 80,

    camera: { x: 0, y: 0, z: 1 },

    // Layers: order matters
    layers: [
      { id: "walls", name: "Стены", visible: true, locked: false },
      { id: "openings", name: "Двери/окна", visible: true, locked: false },
      { id: "rooms", name: "Комнаты", visible: true, locked: false },
      { id: "furniture", name: "Мебель", visible: true, locked: false },
      { id: "dims", name: "Размеры", visible: true, locked: false },
    ],

    walls: [],      // {id, layerId, pts:[{x,y}], thicknessPx, color}
    openings: [],   // {id, layerId, type:'door'|'window', wallId, segIndex, t, widthPx, swing, color}
    rooms: [],      // {id, layerId, pts:[{x,y}], fill, label}
    furniture: [],  // {id, layerId, x,y,w,h, rot, fill, stroke, label}
    dims: [],       // {id, layerId, ax,ay,bx,by, offset}

    selection: { ids: new Set(), primary: null, hover: null },
    clipboard: null,

    draft: {
      wall: null,      // {pts:[], thicknessPx, color}
      room: null,      // {pts:[], fill, label}
      furn: null,      // {x0,y0,x1,y1, ...}
      dim: null,       // {ax,ay,bx,by, offset}
      placingOpening: null, // {type, widthPx}
    },

    interaction: {
      dragging: false,
      dragKind: null,
      dragStartWorld: {x:0,y:0},
      dragStartScreen: {x:0,y:0},
      dragPayload: null,

      panning: false,
      panStart: {x:0,y:0},
      camStart: {x:0,y:0},

      boxSelect: null, // {x0,y0,x1,y1} in world
      rotateMode: false,
    },

    history: {
      undo: [],
      redo: [],
      max: 80,
      dirty: false,
      lastAutosave: 0,
    }
  };

  // ---------- Furniture library ----------
  const FURN_LIB = [
    { name:"Диван", w: 1.8, h: 0.9, fill:"#dfe7f7", stroke:"#5a6ea6" },
    { name:"Кровать", w: 2.0, h: 1.6, fill:"#f7e7df", stroke:"#a6705a" },
    { name:"Стол", w: 1.2, h: 0.8, fill:"#e7f7df", stroke:"#5aa66e" },
    { name:"Шкаф", w: 1.0, h: 0.6, fill:"#f4f4f4", stroke:"#666" },
    { name:"Тумба", w: 0.6, h: 0.4, fill:"#f4f4f4", stroke:"#666" },
    { name:"Кухня модуль", w: 2.4, h: 0.6, fill:"#fff4d6", stroke:"#a68a2a" },
    { name:"Душ", w: 0.9, h: 0.9, fill:"#d6f6ff", stroke:"#2a7fa6" },
    { name:"WC", w: 0.7, h: 0.4, fill:"#d6f6ff", stroke:"#2a7fa6" },
  ];

  function rebuildLibrary() {
    libEl.innerHTML = "";
    for (const it of FURN_LIB) {
      const d = document.createElement("div");
      d.className = "item";
      d.innerHTML = `
        <div class="name">${it.name}</div>
        <div class="meta">${it.w.toFixed(2)}м x ${it.h.toFixed(2)}м</div>
      `;
      d.addEventListener("click", () => {
        setTool("furniture");
        const wpx = it.w * state.pxPerM;
        const hpx = it.h * state.pxPerM;
        const cam = state.camera;
        const centerWorld = screenToWorld(canvas.width/2, canvas.height/2);
        const f = {
          id: uid(),
          layerId: "furniture",
          x: centerWorld.x - wpx/2,
          y: centerWorld.y - hpx/2,
          w: wpx,
          h: hpx,
          rot: 0,
          fill: it.fill,
          stroke: it.stroke,
          label: it.name
        };
        pushHistory();
        state.furniture.push(f);
        selectOnly(f.id);
        refreshUI();
      });
      libEl.appendChild(d);
    }
  }

  // ---------- Camera transforms ----------
  function worldToScreen(x, y) {
    const cam = state.camera;
    return { x: (x - cam.x) * cam.z + canvas.width/2, y: (y - cam.y) * cam.z + canvas.height/2 };
  }
  function screenToWorld(x, y) {
    const cam = state.camera;
    return { x: (x - canvas.width/2) / cam.z + cam.x, y: (y - canvas.height/2) / cam.z + cam.y };
  }

  // ---------- Snap ----------
  function gridStepPx() {
    const cm = clamp(state.gridCm, 5, 200);
    return (cm / 100) * state.pxPerM;
  }

  function snapPoint(worldPt, opts = {}) {
    const disable = opts.disable === true;
    if (disable) return worldPt;

    let x = worldPt.x, y = worldPt.y;

    // Ortho snap relative to reference
    if (state.snapOrtho && opts.orthoRef) {
      const rx = opts.orthoRef.x, ry = opts.orthoRef.y;
      const dx = x - rx, dy = y - ry;
      if (Math.abs(dx) > Math.abs(dy)) y = ry;
      else x = rx;
    }

    // Grid snap
    if (state.snapGrid) {
      const s = gridStepPx();
      x = roundTo(x, s);
      y = roundTo(y, s);
    }

    if (state.snapGeom) {
      // Snap to existing vertices, midpoints, openings centers
      const candidates = [];

      for (const w of state.walls) {
        for (const p of w.pts) candidates.push({x:p.x, y:p.y, w: 1.0});
        for (let i=0;i<w.pts.length-1;i++) {
          const a = w.pts[i], b = w.pts[i+1];
          candidates.push({x:(a.x+b.x)/2, y:(a.y+b.y)/2, w: 0.85});
        }
      }
      for (const r of state.rooms) for (const p of r.pts) candidates.push({x:p.x, y:p.y, w: 0.9});
      for (const f of state.furniture) {
        const c = furnitureCenter(f);
        candidates.push({x:c.x, y:c.y, w: 0.7});
      }

      // Snap to nearest segment projection (perpendicular) when building walls/rooms/dims
      if (opts.allowPerp) {
        for (const w of state.walls) {
          for (let i=0;i<w.pts.length-1;i++) {
            const a = w.pts[i], b = w.pts[i+1];
            const pr = projectPointToSegment(x, y, a.x,a.y,b.x,b.y);
            candidates.push({x:pr.x, y:pr.y, w: 0.8});
          }
        }
      }

      const tol = 12 / state.camera.z; // world px tolerance
      let best = null, bestD = Infinity;
      for (const c of candidates) {
        const d = Math.hypot(x - c.x, y - c.y) / c.w;
        if (d < bestD) { bestD = d; best = c; }
      }
      if (best && bestD <= tol) {
        x = best.x; y = best.y;
      }
    }

    return {x, y};
  }

  // ---------- Layers ----------
  function layerById(id) { return state.layers.find(l => l.id === id); }
  function layerVisible(id) { const l = layerById(id); return l ? l.visible : true; }
  function layerLocked(id) { const l = layerById(id); return l ? l.locked : false; }

  function rebuildLayersUI() {
    layersEl.innerHTML = "";
    for (const l of state.layers) {
      const row = document.createElement("div");
      row.className = "layer";
      row.innerHTML = `
        <div class="name">${l.name}</div>
        <button data-act="vis">${l.visible ? "Скрыть" : "Показать"}</button>
        <button data-act="lock">${l.locked ? "Разл" : "Блок"}</button>
      `;
      row.querySelector('[data-act="vis"]').addEventListener("click", () => {
        l.visible = !l.visible;
        refreshUI();
      });
      row.querySelector('[data-act="lock"]').addEventListener("click", () => {
        l.locked = !l.locked;
        refreshUI();
      });
      layersEl.appendChild(row);
    }
  }

  // ---------- History ----------
  function snapshot() {
    return {
      walls: deepCopy(state.walls),
      openings: deepCopy(state.openings),
      rooms: deepCopy(state.rooms),
      furniture: deepCopy(state.furniture),
      dims: deepCopy(state.dims),
      layers: deepCopy(state.layers),
      pxPerM: state.pxPerM,
      gridCm: state.gridCm,
    };
  }

  function applySnapshot(s) {
    state.walls = deepCopy(s.walls);
    state.openings = deepCopy(s.openings);
    state.rooms = deepCopy(s.rooms);
    state.furniture = deepCopy(s.furniture);
    state.dims = deepCopy(s.dims);
    state.layers = deepCopy(s.layers);
    state.pxPerM = s.pxPerM ?? state.pxPerM;
    state.gridCm = s.gridCm ?? state.gridCm;

    pxPerMEl.value = state.pxPerM;
    gridCmEl.value = state.gridCm;

    // очистить черновики/выбор
    state.draft.wall = null;
    state.draft.room = null;
    state.draft.furn = null;
    state.draft.dim = null;
    state.draft.placingOpening = null;
    clearSelection();
    refreshUI();
  }

  function pushHistory() {
    state.history.undo.push(snapshot());
    if (state.history.undo.length > state.history.max) state.history.undo.shift();
    state.history.redo.length = 0;
    state.history.dirty = true;
  }

  function undo() {
    const u = state.history.undo.pop();
    if (!u) return;
    state.history.redo.push(snapshot());
    applySnapshot(u);
  }

  function redo() {
    const r = state.history.redo.pop();
    if (!r) return;
    state.history.undo.push(snapshot());
    applySnapshot(r);
  }

  function autosaveMaybe() {
    const now = Date.now();
    if (!state.history.dirty) return;
    if (now - state.history.lastAutosave < 1500) return;
    state.history.lastAutosave = now;
    state.history.dirty = false;
    const data = exportProject();
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch {}
  }

  function loadAutosave() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const obj = JSON.parse(raw);
      importProject(obj, true);
      return true;
    } catch { return false; }
  }

  // ---------- Selection ----------
  function clearSelection() {
    state.selection.ids.clear();
    state.selection.primary = null;
    state.selection.hover = null;
  }
  function selectOnly(id) {
    state.selection.ids.clear();
    state.selection.ids.add(id);
    state.selection.primary = id;
  }
  function toggleSelect(id) {
    if (state.selection.ids.has(id)) state.selection.ids.delete(id);
    else state.selection.ids.add(id);
    state.selection.primary = id;
  }
  function isSelected(id) { return state.selection.ids.has(id); }

  function selectedObjects() {
    const ids = state.selection.ids;
    const out = [];
    for (const w of state.walls) if (ids.has(w.id)) out.push({type:"wall", obj:w});
    for (const o of state.openings) if (ids.has(o.id)) out.push({type:"opening", obj:o});
    for (const r of state.rooms) if (ids.has(r.id)) out.push({type:"room", obj:r});
    for (const f of state.furniture) if (ids.has(f.id)) out.push({type:"furniture", obj:f});
    for (const d of state.dims) if (ids.has(d.id)) out.push({type:"dim", obj:d});
    return out;
  }

  // ---------- Geometry helpers ----------
  function furnitureCenter(f) { return { x: f.x + f.w/2, y: f.y + f.h/2 }; }

  function rotatePoint(px, py, cx, cy, ang) {
    const s = Math.sin(ang), c = Math.cos(ang);
    const x = px - cx, y = py - cy;
    return { x: cx + x*c - y*s, y: cy + x*s + y*c };
  }

  function pointInRotRect(pt, f) {
    const c = furnitureCenter(f);
    const inv = rotatePoint(pt.x, pt.y, c.x, c.y, -f.rot);
    return inv.x >= f.x && inv.x <= f.x + f.w && inv.y >= f.y && inv.y <= f.y + f.h;
  }

  function polyArea(pts) {
    let a = 0;
    for (let i=0;i<pts.length;i++) {
      const p = pts[i], q = pts[(i+1)%pts.length];
      a += p.x*q.y - q.x*p.y;
    }
    return a / 2;
  }

  // ---------- Hit testing ----------
  function hitTest(worldPt) {
    // Return topmost object id and type, respecting layer visibility
    const x = worldPt.x, y = worldPt.y;

    // priority: handles for furniture if selected
    const sel = getPrimaryObject();
    if (sel && sel.type === "furniture") {
      const h = hitFurnitureHandle(worldPt, sel.obj);
      if (h) return {type:"handle", id: sel.obj.id, handle: h};
    }

    // furniture topmost (reverse order)
    if (layerVisible("furniture")) {
      for (let i=state.furniture.length-1;i>=0;i--) {
        const f = state.furniture[i];
        if (layerLocked(f.layerId)) continue;
        if (pointInRotRect(worldPt, f)) return {type:"furniture", id:f.id};
      }
    }

    // openings
    if (layerVisible("openings")) {
      for (let i=state.openings.length-1;i>=0;i--) {
        const o = state.openings[i];
        if (layerLocked(o.layerId)) continue;
        const bb = openingBBoxWorld(o);
        if (x >= bb.minx && x <= bb.maxx && y >= bb.miny && y <= bb.maxy) return {type:"opening", id:o.id};
      }
    }

    // rooms
    if (layerVisible("rooms")) {
      for (let i=state.rooms.length-1;i>=0;i--) {
        const r = state.rooms[i];
        if (layerLocked(r.layerId)) continue;
        if (pointInPolygon(worldPt, r.pts)) return {type:"room", id:r.id};
      }
    }

    // walls (segment proximity)
    if (layerVisible("walls")) {
      const tol = 10 / state.camera.z;
      for (let wi=state.walls.length-1;wi>=0;wi--) {
        const w = state.walls[wi];
        if (layerLocked(w.layerId)) continue;
        for (let i=0;i<w.pts.length-1;i++) {
          const a = w.pts[i], b = w.pts[i+1];
          const d = pointToSegmentDistance(x,y,a.x,a.y,b.x,b.y);
          if (d <= tol + (w.thicknessPx||14)/2) return {type:"wall", id:w.id, segIndex:i};
        }
      }
    }

    // dims
    if (layerVisible("dims")) {
      const tol = 8 / state.camera.z;
      for (let i=state.dims.length-1;i>=0;i--) {
        const d = state.dims[i];
        if (layerLocked(d.layerId)) continue;
        const dd = pointToSegmentDistance(x,y,d.ax,d.ay,d.bx,d.by);
        if (dd <= tol) return {type:"dim", id:d.id};
      }
    }

    return null;
  }

  function pointInPolygon(pt, poly) {
    let inside = false;
    for (let i=0,j=poly.length-1;i<poly.length;j=i++) {
      const xi = poly[i].x, yi = poly[i].y;
      const xj = poly[j].x, yj = poly[j].y;
      const intersect = ((yi>pt.y) !== (yj>pt.y)) &&
        (pt.x < (xj - xi) * (pt.y - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function getObjectById(id) {
    for (const w of state.walls) if (w.id === id) return {type:"wall", obj:w};
    for (const o of state.openings) if (o.id === id) return {type:"opening", obj:o};
    for (const r of state.rooms) if (r.id === id) return {type:"room", obj:r};
    for (const f of state.furniture) if (f.id === id) return {type:"furniture", obj:f};
    for (const d of state.dims) if (d.id === id) return {type:"dim", obj:d};
    return null;
  }
  function getPrimaryObject() {
    if (!state.selection.primary) return null;
    return getObjectById(state.selection.primary);
  }

  // ---------- Openings on walls ----------
  function findClosestWallSegment(worldPt) {
    const x = worldPt.x, y = worldPt.y;
    let best = null;
    let bestD = Infinity;
    for (const w of state.walls) {
      if (!layerVisible(w.layerId) || layerLocked(w.layerId)) continue;
      for (let i=0;i<w.pts.length-1;i++) {
        const a = w.pts[i], b = w.pts[i+1];
        const d = pointToSegmentDistance(x,y,a.x,a.y,b.x,b.y);
        if (d < bestD) {
          const pr = projectPointToSegment(x,y,a.x,a.y,b.x,b.y);
          bestD = d;
          best = { wallId: w.id, segIndex: i, t: pr.t, a, b, dist: d };
        }
      }
    }
    return best;
  }

  function openingWorldPose(o) {
    const w = state.walls.find(x => x.id === o.wallId);
    if (!w) return null;
    const i = clamp(o.segIndex, 0, w.pts.length-2);
    const a = w.pts[i], b = w.pts[i+1];
    const x = lerp(a.x, b.x, o.t);
    const y = lerp(a.y, b.y, o.t);
    const ang = Math.atan2(b.y - a.y, b.x - a.x);
    return { x, y, ang, a, b, wall: w };
  }

  function openingBBoxWorld(o) {
    const p = openingWorldPose(o);
    if (!p) return {minx:0,maxx:0,miny:0,maxy:0};
    const wpx = o.widthPx || 90;
    const tpx = (p.wall.thicknessPx || 14);
    // bbox as rotated rect - approximate by axis-aligned using 4 corners
    const cx = p.x, cy = p.y;
    const hw = wpx/2, hh = tpx*1.2;
    const corners = [
      rotatePoint(cx-hw, cy-hh, cx,cy, p.ang),
      rotatePoint(cx+hw, cy-hh, cx,cy, p.ang),
      rotatePoint(cx+hw, cy+hh, cx,cy, p.ang),
      rotatePoint(cx-hw, cy+hh, cx,cy, p.ang),
    ];
    let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
    for (const c of corners) {
      minx = Math.min(minx, c.x); maxx = Math.max(maxx, c.x);
      miny = Math.min(miny, c.y); maxy = Math.max(maxy, c.y);
    }
    return {minx,maxx,miny,maxy};
  }

  // ---------- Furniture handles ----------
  function furnitureHandlesWorld(f) {
    // in local (unrotated) space: corners and rotate handle
    const c = furnitureCenter(f);
    const pts = [
      {key:"nw", x:f.x, y:f.y},
      {key:"ne", x:f.x+f.w, y:f.y},
      {key:"se", x:f.x+f.w, y:f.y+f.h},
      {key:"sw", x:f.x, y:f.y+f.h},
    ].map(p => ({key:p.key, ...rotatePoint(p.x,p.y,c.x,c.y,f.rot)}));

    // rotate handle above "ne-nw" edge center
    const topMidLocal = { x: f.x + f.w/2, y: f.y - Math.max(20, f.h*0.2) };
    const rotHandle = { key:"rot", ...rotatePoint(topMidLocal.x, topMidLocal.y, c.x,c.y,f.rot) };
    return { corners: pts, rot: rotHandle };
  }

  function hitFurnitureHandle(worldPt, f) {
    const h = furnitureHandlesWorld(f);
    const tol = 10 / state.camera.z;
    for (const p of h.corners) {
      if (dist(worldPt.x,worldPt.y,p.x,p.y) <= tol) return {kind:"scale", corner:p.key};
    }
    if (dist(worldPt.x,worldPt.y,h.rot.x,h.rot.y) <= tol) return {kind:"rotate"};
    return null;
  }

  // ---------- UI ----------
  function setStatus(s) { statusEl.textContent = s; }

  function setTool(t) {
    state.tool = t;
    for (const b of toolButtons) b.classList.toggle("active", b.dataset.tool === t);
    state.draft.wall = null;
    state.draft.room = null;
    state.draft.furn = null;
    state.draft.dim = null;

    if (t === "door" || t === "window") {
      state.draft.placingOpening = { type: t, widthPx: (t === "door" ? 90 : 120) };
    } else {
      state.draft.placingOpening = null;
    }

    refreshUI();
  }

  function refreshUI() {
    state.snapGrid = !!snapGridEl.checked;
    state.snapGeom = !!snapGeomEl.checked;
    state.snapOrtho = !!snapOrthoEl.checked;
    state.showDims = !!showDimsEl.checked;

    state.gridCm = clamp(parseInt(gridCmEl.value || "50", 10), 5, 200);
    state.pxPerM = clamp(parseInt(pxPerMEl.value || "80", 10), 20, 400);

    rebuildLayersUI();
    rebuildPropsUI();
    draw();
  }

  function rebuildPropsUI() {
    const primary = getPrimaryObject();
    if (!primary) {
      propsEl.innerHTML = `<div class="muted">Ничего не выбрано</div>`;
      return;
    }
    const {type, obj} = primary;

    if (type === "wall") {
      propsEl.innerHTML = `
        <div class="title">Стена</div>
        <div class="row"><div>Толщина (см)</div><input id="wTh" type="number" min="5" max="80" step="1"></div>
        <div class="row"><div>Цвет</div><input id="wCol" type="color"></div>
        <div class="mini">Узлы стены можно двигать: выдели стену и потяни за вершины (двойной клик по вершине для удаления).</div>
      `;
      const th = document.getElementById("wTh");
      const col = document.getElementById("wCol");
      th.value = Math.round((obj.thicknessPx || 14) / state.pxPerM * 100);
      col.value = obj.color || "#2f2f2f";
      th.addEventListener("input", () => {
        pushHistory();
        obj.thicknessPx = (parseFloat(th.value||"14")/100) * state.pxPerM;
        refreshUI();
      });
      col.addEventListener("input", () => {
        pushHistory();
        obj.color = col.value;
        refreshUI();
      });
      return;
    }

    if (type === "opening") {
      propsEl.innerHTML = `
        <div class="title">${obj.type === "door" ? "Дверь" : "Окно"}</div>
        <div class="row"><div>Ширина (см)</div><input id="oW" type="number" min="30" max="300" step="1"></div>
        <div class="row"><div>Смещение</div><input id="oT" type="range" min="0" max="1000"></div>
        <div class="row"><div>Цвет</div><input id="oCol" type="color"></div>
        <div class="mini">Смещение - позиция вдоль сегмента стены.</div>
      `;
      const oW = document.getElementById("oW");
      const oT = document.getElementById("oT");
      const oCol = document.getElementById("oCol");

      oW.value = Math.round((obj.widthPx||90) / state.pxPerM * 100);
      oT.value = Math.round((obj.t||0) * 1000);
      oCol.value = obj.color || (obj.type==="door" ? "#1f7a34" : "#2a7fa6");

      oW.addEventListener("input", () => {
        pushHistory();
        obj.widthPx = (parseFloat(oW.value||"90")/100) * state.pxPerM;
        refreshUI();
      });
      oT.addEventListener("input", () => {
        pushHistory();
        obj.t = clamp(parseInt(oT.value||"0",10)/1000, 0, 1);
        refreshUI();
      });
      oCol.addEventListener("input", () => {
        pushHistory();
        obj.color = oCol.value;
        refreshUI();
      });
      return;
    }

    if (type === "room") {
      const areaM2 = Math.abs(polyArea(obj.pts)) / (state.pxPerM*state.pxPerM);
      propsEl.innerHTML = `
        <div class="title">Комната</div>
        <div class="row"><div>Название</div><input id="rLab" type="text"></div>
        <div class="row"><div>Заливка</div><input id="rFill" type="color"></div>
        <div class="row"><div>Площадь</div><input type="text" value="${areaM2.toFixed(2)} м2" disabled></div>
      `;
      const rLab = document.getElementById("rLab");
      const rFill = document.getElementById("rFill");
      rLab.value = obj.label || "";
      rFill.value = obj.fill || "#dfeff0";
      rLab.addEventListener("input", () => { pushHistory(); obj.label = rLab.value; refreshUI(); });
      rFill.addEventListener("input", () => { pushHistory(); obj.fill = rFill.value; refreshUI(); });
      return;
    }

    if (type === "furniture") {
      const wM = obj.w / state.pxPerM;
      const hM = obj.h / state.pxPerM;
      propsEl.innerHTML = `
        <div class="title">Мебель</div>
        <div class="row"><div>Название</div><input id="fLab" type="text"></div>
        <div class="row"><div>Ширина (см)</div><input id="fW" type="number" min="10" max="1000" step="1"></div>
        <div class="row"><div>Глубина (см)</div><input id="fH" type="number" min="10" max="1000" step="1"></div>
        <div class="row"><div>Поворот (град)</div><input id="fR" type="number" min="-180" max="180" step="1"></div>
        <div class="row"><div>Заливка</div><input id="fFill" type="color"></div>
        <div class="row"><div>Контур</div><input id="fSt" type="color"></div>
      `;
      const fLab = document.getElementById("fLab");
      const fW = document.getElementById("fW");
      const fH = document.getElementById("fH");
      const fR = document.getElementById("fR");
      const fFill = document.getElementById("fFill");
      const fSt = document.getElementById("fSt");

      fLab.value = obj.label || "";
      fW.value = Math.round(wM * 100);
      fH.value = Math.round(hM * 100);
      fR.value = Math.round(deg(obj.rot||0));
      fFill.value = obj.fill || "#e9e9e9";
      fSt.value = obj.stroke || "#666666";

      fLab.addEventListener("input", () => { pushHistory(); obj.label = fLab.value; refreshUI(); });
      fW.addEventListener("input", () => { pushHistory(); obj.w = (parseFloat(fW.value||"0")/100) * state.pxPerM; refreshUI(); });
      fH.addEventListener("input", () => { pushHistory(); obj.h = (parseFloat(fH.value||"0")/100) * state.pxPerM; refreshUI(); });
      fR.addEventListener("input", () => { pushHistory(); obj.rot = rad(parseFloat(fR.value||"0")); refreshUI(); });
      fFill.addEventListener("input", () => { pushHistory(); obj.fill = fFill.value; refreshUI(); });
      fSt.addEventListener("input", () => { pushHistory(); obj.stroke = fSt.value; refreshUI(); });
      return;
    }

    if (type === "dim") {
      const lenM = dist(obj.ax,obj.ay,obj.bx,obj.by) / state.pxPerM;
      propsEl.innerHTML = `
        <div class="title">Размер</div>
        <div class="row"><div>Длина</div><input type="text" value="${(lenM*100).toFixed(0)} см" disabled></div>
        <div class="row"><div>Смещение</div><input id="dOf" type="number" min="-500" max="500" step="1"></div>
      `;
      const dOf = document.getElementById("dOf");
      dOf.value = obj.offset ?? 20;
      dOf.addEventListener("input", () => { pushHistory(); obj.offset = parseFloat(dOf.value||"0"); refreshUI(); });
      return;
    }
  }

  // ---------- Draw ----------
  function resizeCanvasToCSS() {
    const r = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(600, Math.floor(r.width * dpr));
    const h = Math.max(400, Math.floor(r.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
  }

  function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#f0f2f5";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function drawGrid() {
    const step = gridStepPx();
    const cam = state.camera;
    const z = cam.z;

    const leftWorld = cam.x - (canvas.width/2)/z;
    const rightWorld = cam.x + (canvas.width/2)/z;
    const topWorld = cam.y - (canvas.height/2)/z;
    const bottomWorld = cam.y + (canvas.height/2)/z;

    const x0 = Math.floor(leftWorld / step) * step;
    const y0 = Math.floor(topWorld / step) * step;

    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.lineWidth = 1;

    for (let x = x0; x <= rightWorld; x += step) {
      const s = worldToScreen(x, 0).x;
      ctx.beginPath();
      ctx.moveTo(s, 0);
      ctx.lineTo(s, canvas.height);
      ctx.stroke();
    }
    for (let y = y0; y <= bottomWorld; y += step) {
      const s = worldToScreen(0, y).y;
      ctx.beginPath();
      ctx.moveTo(0, s);
      ctx.lineTo(canvas.width, s);
      ctx.stroke();
    }

    // axis
    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    const ax = worldToScreen(0,0).x;
    const ay = worldToScreen(0,0).y;
    ctx.beginPath(); ctx.moveTo(ax,0); ctx.lineTo(ax,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,ay); ctx.lineTo(canvas.width,ay); ctx.stroke();

    ctx.restore();
  }

  function drawWalls() {
    if (!layerVisible("walls")) return;
    for (const w of state.walls) {
      if (!layerVisible(w.layerId)) continue;

      const thick = w.thicknessPx || 14;
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = w.color || "#2f2f2f";
      ctx.lineWidth = thick * state.camera.z;

      ctx.beginPath();
      for (let i=0;i<w.pts.length;i++) {
        const p = w.pts[i];
        const s = worldToScreen(p.x,p.y);
        if (i === 0) ctx.moveTo(s.x,s.y);
        else ctx.lineTo(s.x,s.y);
      }
      ctx.stroke();

      // endpoints
      ctx.fillStyle = isSelected(w.id) ? "rgba(64,120,255,0.95)" : "rgba(0,0,0,0.25)";
      const r = 4 * state.camera.z;
      for (const p of w.pts) {
        const s = worldToScreen(p.x,p.y);
        ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.fill();
      }

      ctx.restore();
    }
  }

  function drawOpenings() {
    if (!layerVisible("openings")) return;
    for (const o of state.openings) {
      if (!layerVisible(o.layerId)) continue;
      const pose = openingWorldPose(o);
      if (!pose) continue;
      const wpx = o.widthPx || 90;
      const tpx = (pose.wall.thicknessPx || 14) * 1.3;
      const cx = pose.x, cy = pose.y;

      ctx.save();
      const sC = worldToScreen(cx,cy);
      ctx.translate(sC.x, sC.y);
      ctx.rotate(pose.ang);
      ctx.scale(state.camera.z, state.camera.z);

      ctx.strokeStyle = o.color || (o.type==="door" ? "#1f7a34" : "#2a7fa6");
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 2 / state.camera.z;

      // opening body
      ctx.beginPath();
      ctx.rect(-wpx/2, -tpx/2, wpx, tpx);
      ctx.fill();
      ctx.stroke();

      // door swing arc
      if (o.type === "door") {
        ctx.strokeStyle = "rgba(31,122,52,0.8)";
        ctx.beginPath();
        ctx.moveTo(-wpx/2, 0);
        ctx.lineTo(-wpx/2, -wpx/2);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(-wpx/2, 0, wpx/2, -Math.PI/2, 0, false);
        ctx.stroke();
      } else {
        // window line
        ctx.strokeStyle = "rgba(42,127,166,0.8)";
        ctx.beginPath();
        ctx.moveTo(-wpx/2, 0);
        ctx.lineTo(wpx/2, 0);
        ctx.stroke();
      }

      // selection outline
      if (isSelected(o.id)) {
        ctx.strokeStyle = "rgba(64,120,255,0.95)";
        ctx.lineWidth = 2 / state.camera.z;
        ctx.strokeRect(-wpx/2-3, -tpx/2-3, wpx+6, tpx+6);
      }

      ctx.restore();
    }
  }

  function drawRooms() {
    if (!layerVisible("rooms")) return;
    for (const r of state.rooms) {
      if (!layerVisible(r.layerId)) continue;
      if (r.pts.length < 3) continue;

      ctx.save();
      ctx.beginPath();
      for (let i=0;i<r.pts.length;i++) {
        const p = r.pts[i];
        const s = worldToScreen(p.x,p.y);
        if (i===0) ctx.moveTo(s.x,s.y);
        else ctx.lineTo(s.x,s.y);
      }
      ctx.closePath();
      ctx.fillStyle = r.fill || "rgba(200,230,235,0.7)";
      ctx.fill();
      ctx.strokeStyle = isSelected(r.id) ? "rgba(64,120,255,0.95)" : "rgba(0,0,0,0.2)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // label at centroid
      const c = polygonCentroid(r.pts);
      const sC = worldToScreen(c.x,c.y);
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.font = `${Math.round(14*state.camera.z)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const areaM2 = Math.abs(polyArea(r.pts)) / (state.pxPerM*state.pxPerM);
      const label = (r.label && r.label.trim()) ? `${r.label} (${areaM2.toFixed(1)} м2)` : `${areaM2.toFixed(1)} м2`;
      ctx.fillText(label, sC.x, sC.y);

      ctx.restore();
    }
  }

  function polygonCentroid(pts) {
    let cx=0, cy=0;
    let a = 0;
    for (let i=0;i<pts.length;i++) {
      const p=pts[i], q=pts[(i+1)%pts.length];
      const cross = p.x*q.y - q.x*p.y;
      a += cross;
      cx += (p.x+q.x) * cross;
      cy += (p.y+q.y) * cross;
    }
    a *= 0.5;
    if (Math.abs(a) < 1e-9) {
      // fallback average
      for (const p of pts) { cx += p.x; cy += p.y; }
      return {x: cx/pts.length, y: cy/pts.length};
    }
    cx /= (6*a); cy /= (6*a);
    return {x: cx, y: cy};
  }

  function drawFurniture() {
    if (!layerVisible("furniture")) return;

    for (const f of state.furniture) {
      if (!layerVisible(f.layerId)) continue;

      const c = furnitureCenter(f);
      const sC = worldToScreen(c.x,c.y);

      ctx.save();
      ctx.translate(sC.x, sC.y);
      ctx.rotate(f.rot || 0);
      ctx.scale(state.camera.z, state.camera.z);
      ctx.translate(-f.w/2, -f.h/2);

      ctx.fillStyle = f.fill || "#e9e9e9";
      ctx.strokeStyle = f.stroke || "#666";
      ctx.lineWidth = 2 / state.camera.z;
      ctx.beginPath();
      ctx.rect(0,0,f.w,f.h);
      ctx.fill();
      ctx.stroke();

      // label
      if (f.label) {
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.font = `14px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(f.label, f.w/2, f.h/2);
      }

      // selection + handles
      if (isSelected(f.id)) {
        ctx.strokeStyle = "rgba(64,120,255,0.95)";
        ctx.setLineDash([6,4]);
        ctx.strokeRect(-4, -4, f.w+8, f.h+8);
        ctx.setLineDash([]);

        // handles in world-space
        ctx.restore();
        drawFurnitureHandles(f);
      } else {
        ctx.restore();
      }
    }
  }

  function drawFurnitureHandles(f) {
    const h = furnitureHandlesWorld(f);
    const r = 6 * state.camera.z;

    ctx.save();
    ctx.fillStyle = "rgba(64,120,255,0.95)";
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;

    for (const p of h.corners) {
      const s = worldToScreen(p.x,p.y);
      ctx.beginPath();
      ctx.arc(s.x,s.y,r,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }
    // rotate handle
    {
      const s = worldToScreen(h.rot.x,h.rot.y);
      ctx.beginPath();
      ctx.arc(s.x,s.y,r,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      const c = furnitureCenter(f);
      const sc = worldToScreen(c.x,c.y);
      ctx.lineTo(sc.x, sc.y);
      ctx.strokeStyle = "rgba(64,120,255,0.6)";
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawDims() {
    if (!layerVisible("dims")) return;
    if (!state.showDims) return;

    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.55)";
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.lineWidth = 2;

    for (const d of state.dims) {
      if (!layerVisible(d.layerId)) continue;
      if (layerLocked(d.layerId)) continue;

      drawDim(d, isSelected(d.id));
    }

    // draft dim
    if (state.draft.dim && state.draft.dim.ax != null) {
      drawDim(state.draft.dim, false, true);
    }

    ctx.restore();
  }

  function drawDim(d, selected, isDraft=false) {
    const ax=d.ax, ay=d.ay, bx=d.bx, by=d.by;
    if (ax==null || bx==null) return;
    const off = d.offset ?? 20;

    const dx = bx - ax, dy = by - ay;
    const len = Math.hypot(dx,dy);
    if (len < 1e-6) return;
    const nx = -dy/len, ny = dx/len;

    const a2 = { x: ax + nx*off, y: ay + ny*off };
    const b2 = { x: bx + nx*off, y: by + ny*off };

    const sA = worldToScreen(ax,ay);
    const sB = worldToScreen(bx,by);
    const sA2 = worldToScreen(a2.x,a2.y);
    const sB2 = worldToScreen(b2.x,b2.y);

    ctx.save();
    ctx.strokeStyle = selected ? "rgba(64,120,255,0.95)" : (isDraft ? "rgba(0,0,0,0.35)" : "rgba(0,0,0,0.55)");
    ctx.fillStyle = selected ? "rgba(64,120,255,0.95)" : "rgba(0,0,0,0.75)";
    ctx.lineWidth = 2;

    // extension lines
    ctx.beginPath(); ctx.moveTo(sA.x,sA.y); ctx.lineTo(sA2.x,sA2.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sB.x,sB.y); ctx.lineTo(sB2.x,sB2.y); ctx.stroke();

    // dim line
    ctx.beginPath(); ctx.moveTo(sA2.x,sA2.y); ctx.lineTo(sB2.x,sB2.y); ctx.stroke();

    // arrows
    drawArrow(sA2, sB2);
    drawArrow(sB2, sA2);

    // label
    const mid = { x: (a2.x+b2.x)/2, y:(a2.y+b2.y)/2 };
    const sM = worldToScreen(mid.x, mid.y);
    const lenM = len / state.pxPerM;
    const text = `${(lenM*100).toFixed(0)} см`;
    ctx.font = `${Math.round(12*state.camera.z)}px system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(text, sM.x, sM.y - 6);

    ctx.restore();
  }

  function drawArrow(a, b) {
    const ang = Math.atan2(b.y - a.y, b.x - a.x);
    const size = 10;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(a.x + Math.cos(ang + Math.PI*0.85)*size, a.y + Math.sin(ang + Math.PI*0.85)*size);
    ctx.lineTo(a.x + Math.cos(ang - Math.PI*0.85)*size, a.y + Math.sin(ang - Math.PI*0.85)*size);
    ctx.closePath();
    ctx.fill();
  }

  function drawDrafts() {
    // wall draft
    if (state.draft.wall && state.draft.wall.pts.length) {
      const w = state.draft.wall;
      ctx.save();
      ctx.lineCap="round"; ctx.lineJoin="round";
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = (w.thicknessPx||14) * state.camera.z;
      ctx.beginPath();
      for (let i=0;i<w.pts.length;i++) {
        const s = worldToScreen(w.pts[i].x, w.pts[i].y);
        if (i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    // room draft
    if (state.draft.room && state.draft.room.pts.length) {
      const r = state.draft.room;
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.fillStyle = "rgba(200,230,235,0.25)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i=0;i<r.pts.length;i++) {
        const s = worldToScreen(r.pts[i].x, r.pts[i].y);
        if (i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
      }
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    // furniture drag draft
    if (state.draft.furn) {
      const f = state.draft.furn;
      const x = Math.min(f.x0, f.x1), y = Math.min(f.y0, f.y1);
      const w = Math.abs(f.x1 - f.x0), h = Math.abs(f.y1 - f.y0);
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.setLineDash([6,4]);
      ctx.lineWidth = 2;
      const s0 = worldToScreen(x,y);
      const s1 = worldToScreen(x+w,y+h);
      ctx.strokeRect(s0.x,s0.y, s1.x-s0.x, s1.y-s0.y);
      ctx.restore();
    }

    // box select
    if (state.interaction.boxSelect) {
      const b = state.interaction.boxSelect;
      const x = Math.min(b.x0,b.x1), y = Math.min(b.y0,b.y1);
      const w = Math.abs(b.x1-b.x0), h = Math.abs(b.y1-b.y0);
      ctx.save();
      ctx.strokeStyle = "rgba(64,120,255,0.9)";
      ctx.fillStyle = "rgba(64,120,255,0.12)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      const s0 = worldToScreen(x,y);
      const s1 = worldToScreen(x+w,y+h);
      ctx.fillRect(s0.x,s0.y, s1.x-s0.x, s1.y-s0.y);
      ctx.strokeRect(s0.x,s0.y, s1.x-s0.x, s1.y-s0.y);
      ctx.restore();
    }
  }

  function draw() {
    resizeCanvasToCSS();
    clear();
    drawGrid();
    drawRooms();
    drawWalls();
    drawOpenings();
    drawFurniture();
    drawDims();
    drawDrafts();
    autosaveMaybe();
  }

  // ---------- Tool actions ----------
  function addWallPoint(pt) {
    if (!state.draft.wall) {
      state.draft.wall = { pts: [], thicknessPx: 14, color: "#2f2f2f" };
    }
    state.draft.wall.pts.push({x:pt.x, y:pt.y});
  }

  function finishWall() {
    const w = state.draft.wall;
    if (!w || w.pts.length < 2) { state.draft.wall = null; return; }
    pushHistory();
    state.walls.push({
      id: uid(),
      layerId: "walls",
      pts: w.pts,
      thicknessPx: w.thicknessPx ?? 14,
      color: w.color || "#2f2f2f"
    });
    state.draft.wall = null;
    refreshUI();
  }

  function addRoomPoint(pt) {
    if (!state.draft.room) {
      state.draft.room = { pts: [], fill: "#dfeff0", label: "" };
    }
    state.draft.room.pts.push({x:pt.x, y:pt.y});
  }

  function finishRoom() {
    const r = state.draft.room;
    if (!r || r.pts.length < 3) { state.draft.room = null; return; }
    pushHistory();
    state.rooms.push({
      id: uid(),
      layerId: "rooms",
      pts: r.pts,
      fill: r.fill || "#dfeff0",
      label: r.label || ""
    });
    state.draft.room = null;
    refreshUI();
  }

  function addDimension(ax, ay, bx, by) {
    pushHistory();
    state.dims.push({ id: uid(), layerId:"dims", ax,ay,bx,by, offset: 20 });
    refreshUI();
  }

  function placeOpeningAt(worldPt, type) {
    const hit = findClosestWallSegment(worldPt);
    if (!hit) { setStatus("Нет стены рядом"); return; }

    const wall = state.walls.find(w => w.id === hit.wallId);
    if (!wall) return;

    // reject if too far
    const tol = 18 / state.camera.z + (wall.thicknessPx||14);
    if (hit.dist > tol) { setStatus("Поднеси ближе к стене"); return; }

    const widthPx = (type === "door" ? 0.9 : 1.2) * state.pxPerM;
    pushHistory();
    state.openings.push({
      id: uid(),
      layerId: "openings",
      type,
      wallId: hit.wallId,
      segIndex: hit.segIndex,
      t: hit.t,
      widthPx,
      swing: 1,
      color: type==="door" ? "#1f7a34" : "#2a7fa6"
    });
    refreshUI();
  }

  // ---------- Delete / Clear ----------
  function deleteSelection() {
    const ids = state.selection.ids;
    if (!ids.size) return;
    pushHistory();

    state.walls = state.walls.filter(o => !ids.has(o.id));
    state.rooms = state.rooms.filter(o => !ids.has(o.id));
    state.furniture = state.furniture.filter(o => !ids.has(o.id));
    state.dims = state.dims.filter(o => !ids.has(o.id));
    state.openings = state.openings.filter(o => !ids.has(o.id));

    // openings whose wall deleted
    const wallIds = new Set(state.walls.map(w => w.id));
    state.openings = state.openings.filter(o => wallIds.has(o.wallId));

    clearSelection();
    refreshUI();
  }

  function clearAll() {
    pushHistory();
    state.walls = [];
    state.openings = [];
    state.rooms = [];
    state.furniture = [];
    state.dims = [];
    clearSelection();
    refreshUI();
  }

  // ---------- Export / Import ----------
  function exportProject() {
    return {
      version: 1,
      meta: { savedAt: new Date().toISOString() },
      settings: {
        pxPerM: state.pxPerM,
        gridCm: state.gridCm
      },
      layers: state.layers,
      data: {
        walls: state.walls,
        openings: state.openings,
        rooms: state.rooms,
        furniture: state.furniture,
        dims: state.dims
      }
    };
  }

  function importProject(obj, silent=false) {
    if (!obj || !obj.data) return;
    const snap = {
      walls: obj.data.walls || [],
      openings: obj.data.openings || [],
      rooms: obj.data.rooms || [],
      furniture: obj.data.furniture || [],
      dims: obj.data.dims || [],
      layers: obj.layers || state.layers,
      pxPerM: obj.settings?.pxPerM ?? state.pxPerM,
      gridCm: obj.settings?.gridCm ?? state.gridCm,
    };
    if (!silent) pushHistory();
    applySnapshot(snap);
  }

  function downloadJSON() {
    const data = exportProject();
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "project.json";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function exportPNG() {
    // Render at current view
    const link = document.createElement("a");
    link.download = "plan.png";
    link.href = canvas.toDataURL("image/png");
    link.click();
  }

  // ---------- Interaction ----------
  let mouse = { x:0,y:0, buttons:0 };
  let keys = { space:false, alt:false, shift:false, ctrl:false };

  function onMouseMove(e) {
    mouse.x = e.offsetX * (canvas.width / canvas.getBoundingClientRect().width);
    mouse.y = e.offsetY * (canvas.height / canvas.getBoundingClientRect().height);

    const world = screenToWorld(mouse.x, mouse.y);
    const snapped = snapPoint(world, {
      disable: keys.alt,
      orthoRef: getOrthoRef(),
      allowPerp: (state.tool === "wall" || state.tool === "room" || state.tool === "dimension")
    });

    if (state.interaction.panning) {
      const dx = (mouse.x - state.interaction.panStart.x) / state.camera.z;
      const dy = (mouse.y - state.interaction.panStart.y) / state.camera.z;
      state.camera.x = state.interaction.camStart.x - dx;
      state.camera.y = state.interaction.camStart.y - dy;
      draw();
      return;
    }

    if (state.interaction.dragging) {
      dragUpdate(snapped);
      draw();
      return;
    }

    if (state.interaction.boxSelect) {
      state.interaction.boxSelect.x1 = snapped.x;
      state.interaction.boxSelect.y1 = snapped.y;
      draw();
      return;
    }

    // draft updates
    if (state.tool === "wall" && state.draft.wall && state.draft.wall.pts.length) {
      // preview last segment to cursor
      const pts = state.draft.wall.pts;
      if (pts.length >= 1) {
        const last = pts[pts.length-1];
        state.draft.wall.ptsPreview = { from:last, to: snapped };
      }
      setStatus(`Стена: ${fmtPoint(snapped)}`);
    } else if (state.tool === "room" && state.draft.room && state.draft.room.pts.length) {
      setStatus(`Комната: ${fmtPoint(snapped)}`);
    } else if (state.tool === "door" || state.tool === "window") {
      const hit = findClosestWallSegment(snapped);
      setStatus(hit ? `${state.tool === "door" ? "Дверь" : "Окно"}: наведи на стену и кликни` : "Нет стен");
    } else if (state.tool === "dimension" && state.draft.dim && state.draft.dim.ax != null) {
      state.draft.dim.bx = snapped.x;
      state.draft.dim.by = snapped.y;
      setStatus(`Размер: ${fmtLen(dist(state.draft.dim.ax,state.draft.dim.ay,snapped.x,snapped.y))}`);
    } else {
      setStatus(`Курсор: ${fmtPoint(snapped)}`);
    }

    // hover
    const h = hitTest(snapped);
    state.selection.hover = h ? h.id : null;
    draw();
  }

  function getOrthoRef() {
    if (!state.snapOrtho) return null;
    if (state.tool === "wall" && state.draft.wall && state.draft.wall.pts.length) return state.draft.wall.pts[state.draft.wall.pts.length-1];
    if (state.tool === "room" && state.draft.room && state.draft.room.pts.length) return state.draft.room.pts[state.draft.room.pts.length-1];
    if (state.tool === "dimension" && state.draft.dim && state.draft.dim.ax != null) return {x:state.draft.dim.ax, y:state.draft.dim.ay};
    return null;
  }

  function onMouseDown(e) {
    canvas.focus?.();
    mouse.buttons = e.buttons;

    const sx = e.offsetX * (canvas.width / canvas.getBoundingClientRect().width);
    const sy = e.offsetY * (canvas.height / canvas.getBoundingClientRect().height);
    const world = screenToWorld(sx, sy);
    const snapped = snapPoint(world, { disable: keys.alt, orthoRef: getOrthoRef(), allowPerp:true });

    // start pan
    if (keys.space || e.button === 1) {
      state.interaction.panning = true;
      state.interaction.panStart = {x:sx,y:sy};
      state.interaction.camStart = {x:state.camera.x, y:state.camera.y};
      return;
    }

    // tool actions
    if (state.tool === "wall") {
      // first click
      if (!state.draft.wall) state.draft.wall = { pts: [], thicknessPx: 14, color: "#2f2f2f" };
      addWallPoint(snapped);
      draw();
      return;
    }

    if (state.tool === "room") {
      if (!state.draft.room) state.draft.room = { pts: [], fill: "#dfeff0", label: "" };
      addRoomPoint(snapped);
      draw();
      return;
    }

    if (state.tool === "furniture") {
      // start drag-create furniture
      state.draft.furn = { x0: snapped.x, y0: snapped.y, x1: snapped.x, y1: snapped.y };
      state.interaction.dragging = true;
      state.interaction.dragKind = "createFurniture";
      return;
    }

    if (state.tool === "door" || state.tool === "window") {
      placeOpeningAt(snapped, state.tool);
      return;
    }

    if (state.tool === "dimension") {
      if (!state.draft.dim) {
        state.draft.dim = { ax: snapped.x, ay: snapped.y, bx: snapped.x, by: snapped.y, offset: 20 };
        setStatus("Размер: выбери вторую точку");
      } else {
        addDimension(state.draft.dim.ax, state.draft.dim.ay, snapped.x, snapped.y);
        state.draft.dim = null;
      }
      draw();
      return;
    }

    // selection tool
    if (state.tool === "select") {
      const hit = hitTest(snapped);

      if (!hit) {
        // start box select
        state.interaction.boxSelect = { x0: snapped.x, y0: snapped.y, x1: snapped.x, y1: snapped.y };
        if (!keys.shift) clearSelection();
        draw();
        return;
      }

      if (hit.type === "handle") {
        if (!keys.shift && !isSelected(hit.id)) selectOnly(hit.id);
        state.interaction.dragging = true;
        state.interaction.dragKind = "handle";
        state.interaction.dragPayload = { id: hit.id, handle: hit.handle, start: deepCopy(getObjectById(hit.id).obj) };
        state.interaction.dragStartWorld = snapped;
        pushHistory();
        return;
      }

      // normal object click
      if (keys.shift) toggleSelect(hit.id);
      else selectOnly(hit.id);

      refreshUI();

      // start drag move
      const objInfo = getObjectById(hit.id);
      if (objInfo && !layerLocked(objInfo.obj.layerId)) {
        state.interaction.dragging = true;
        state.interaction.dragKind = "move";
        state.interaction.dragPayload = {
          ids: [...state.selection.ids],
          startWorld: snapped,
          originals: deepCopy(selectedObjects().map(x => ({type:x.type, id:x.obj.id, obj:x.obj})))
        };
        state.interaction.dragStartWorld = snapped;
        pushHistory();
      }
    }
  }

  function onMouseUp(e) {
    if (state.interaction.panning) {
      state.interaction.panning = false;
      return;
    }

    if (state.interaction.dragging) {
      // finalize create furniture
      if (state.interaction.dragKind === "createFurniture" && state.draft.furn) {
        const f = state.draft.furn;
        const x = Math.min(f.x0,f.x1), y = Math.min(f.y0,f.y1);
        const w = Math.abs(f.x1-f.x0), h = Math.abs(f.y1-f.y0);

        if (w > 8 && h > 8) {
          pushHistory();
          const obj = {
            id: uid(),
            layerId:"furniture",
            x, y, w, h,
            rot: 0,
            fill:"#e9e9e9",
            stroke:"#666666",
            label:""
          };
          state.furniture.push(obj);
          selectOnly(obj.id);
        }
        state.draft.furn = null;
        refreshUI();
      }

      state.interaction.dragging = false;
      state.interaction.dragKind = null;
      state.interaction.dragPayload = null;
      draw();
    }

    if (state.interaction.boxSelect) {
      const b = state.interaction.boxSelect;
      const x0 = Math.min(b.x0,b.x1), y0 = Math.min(b.y0,b.y1);
      const x1 = Math.max(b.x0,b.x1), y1 = Math.max(b.y0,b.y1);

      const hits = [];
      // furniture inside box (center in box)
      for (const f of state.furniture) {
        if (!layerVisible(f.layerId) || layerLocked(f.layerId)) continue;
        const c = furnitureCenter(f);
        if (c.x>=x0 && c.x<=x1 && c.y>=y0 && c.y<=y1) hits.push(f.id);
      }
      // rooms centroid
      for (const r of state.rooms) {
        if (!layerVisible(r.layerId) || layerLocked(r.layerId)) continue;
        const c = polygonCentroid(r.pts);
        if (c.x>=x0 && c.x<=x1 && c.y>=y0 && c.y<=y1) hits.push(r.id);
      }
      // openings center
      for (const o of state.openings) {
        if (!layerVisible(o.layerId) || layerLocked(o.layerId)) continue;
        const p = openingWorldPose(o);
        if (!p) continue;
        if (p.x>=x0 && p.x<=x1 && p.y>=y0 && p.y<=y1) hits.push(o.id);
      }
      // walls: any vertex in box
      for (const w of state.walls) {
        if (!layerVisible(w.layerId) || layerLocked(w.layerId)) continue;
        for (const p of w.pts) {
          if (p.x>=x0 && p.x<=x1 && p.y>=y0 && p.y<=y1) { hits.push(w.id); break; }
        }
      }

      for (const id of hits) state.selection.ids.add(id);
      state.selection.primary = hits[0] || state.selection.primary;

      state.interaction.boxSelect = null;
      refreshUI();
    }
  }

  function dragUpdate(snapped) {
    const kind = state.interaction.dragKind;
    if (kind === "createFurniture") {
      state.draft.furn.x1 = snapped.x;
      state.draft.furn.y1 = snapped.y;
      return;
    }

    if (kind === "move") {
      const p = state.interaction.dragPayload;
      const dx = snapped.x - p.startWorld.x;
      const dy = snapped.y - p.startWorld.y;

      // move objects by type
      for (const rec of p.originals) {
        const cur = getObjectById(rec.id);
        if (!cur) continue;
        if (cur.type === "furniture") { cur.obj.x = rec.obj.x + dx; cur.obj.y = rec.obj.y + dy; }
        if (cur.type === "room") {
          cur.obj.pts = rec.obj.pts.map(pt => ({x: pt.x + dx, y: pt.y + dy}));
        }
        if (cur.type === "wall") {
          cur.obj.pts = rec.obj.pts.map(pt => ({x: pt.x + dx, y: pt.y + dy}));
        }
        if (cur.type === "dim") {
          cur.obj.ax = rec.obj.ax + dx; cur.obj.ay = rec.obj.ay + dy;
          cur.obj.bx = rec.obj.bx + dx; cur.obj.by = rec.obj.by + dy;
        }
        if (cur.type === "opening") {
          // move opening along wall by projecting new center to its segment
          const pose = openingWorldPose(cur.obj);
          if (pose) {
            const pr = projectPointToSegment(snapped.x, snapped.y, pose.a.x,pose.a.y,pose.b.x,pose.b.y);
            cur.obj.t = pr.t;
          }
        }
      }
      return;
    }

    if (kind === "handle") {
      const payload = state.interaction.dragPayload;
      const fInfo = getObjectById(payload.id);
      if (!fInfo || fInfo.type !== "furniture") return;
      const f = fInfo.obj;

      const start = payload.start;
      const c0 = furnitureCenter(start);
      const c = furnitureCenter(f);

      if (payload.handle.kind === "rotate") {
        const a0 = Math.atan2(state.interaction.dragStartWorld.y - c0.y, state.interaction.dragStartWorld.x - c0.x);
        const a1 = Math.atan2(snapped.y - c0.y, snapped.x - c0.x);
        let da = a1 - a0;
        if (keys.shift) {
          const step = rad(15);
          da = roundTo(da, step);
        }
        f.rot = (start.rot || 0) + da;
        return;
      }

      if (payload.handle.kind === "scale") {
        // scale around opposite corner in local space
        const corner = payload.handle.corner;

        // Convert snapped point into local (unrotated) space of start rect
        const inv = rotatePoint(snapped.x, snapped.y, c0.x, c0.y, -(start.rot||0));
        const minW = 10, minH = 10;

        let x = start.x, y = start.y, w = start.w, h = start.h;
        if (corner === "se") { w = Math.max(minW, inv.x - start.x); h = Math.max(minH, inv.y - start.y); }
        if (corner === "ne") { w = Math.max(minW, inv.x - start.x); const ny = Math.min(start.y + start.h - minH, inv.y); h = (start.y + start.h) - ny; y = ny; }
        if (corner === "sw") { const nx = Math.min(start.x + start.w - minW, inv.x); w = (start.x + start.w) - nx; x = nx; h = Math.max(minH, inv.y - start.y); }
        if (corner === "nw") { const nx = Math.min(start.x + start.w - minW, inv.x); const ny = Math.min(start.y + start.h - minH, inv.y); w = (start.x + start.w) - nx; h = (start.y + start.h) - ny; x = nx; y = ny; }

        // Apply to f keeping same rotation, position is in unrotated basis around start center
        f.w = w; f.h = h;
        // keep center constant in world
        const cNewLocal = { x: x + w/2, y: y + h/2 };
        const cNewWorld = rotatePoint(cNewLocal.x, cNewLocal.y, c0.x, c0.y, (start.rot||0));
        const cStartWorld = c0;
        const dx = cStartWorld.x - cNewWorld.x;
        const dy = cStartWorld.y - cNewWorld.y;

        // move by dx,dy in world, then convert to rect top-left in local and rotate back
        const localTopLeft = { x: x + dx, y: y + dy };
        // This is approximate but stable enough visually
        f.x = localTopLeft.x;
        f.y = localTopLeft.y;

        return;
      }
    }
  }

  // ---------- Keyboard ----------
  function onKeyDown(e) {
    keys.space = e.code === "Space" ? true : keys.space;
    keys.alt = e.altKey;
    keys.shift = e.shiftKey;
    keys.ctrl = e.ctrlKey || e.metaKey;

    if (e.code === "Escape") {
      state.draft.wall = null;
      state.draft.room = null;
      state.draft.furn = null;
      state.draft.dim = null;
      setStatus("Отменено");
      draw();
    }

    if (e.code === "Enter") {
      if (state.tool === "wall") finishWall();
      if (state.tool === "room") finishRoom();
      draw();
    }

    if (e.code === "Delete" || e.code === "Backspace") {
      deleteSelection();
      e.preventDefault();
    }

    // Undo/Redo
    if (keys.ctrl && !keys.shift && e.code === "KeyZ") { undo(); e.preventDefault(); }
    if (keys.ctrl && (e.code === "KeyY" || (keys.shift && e.code === "KeyZ"))) { redo(); e.preventDefault(); }

    // Copy/Paste/Duplicate
    if (keys.ctrl && e.code === "KeyC") { copySelection(); e.preventDefault(); }
    if (keys.ctrl && e.code === "KeyV") { pasteClipboard(); e.preventDefault(); }
    if (keys.ctrl && e.code === "KeyD") { duplicateSelection(); e.preventDefault(); }

    // Rotate mode toggle
    if (e.code === "KeyR") {
      const p = getPrimaryObject();
      if (p && p.type === "furniture") {
        state.interaction.rotateMode = !state.interaction.rotateMode;
        setStatus(state.interaction.rotateMode ? "Режим поворота: колесо или движение мыши" : "Режим поворота выкл");
      }
    }

    // quick tool hotkeys
    if (!keys.ctrl && !keys.alt) {
      if (e.code === "Digit1") setTool("select");
      if (e.code === "Digit2") setTool("wall");
      if (e.code === "Digit3") setTool("door");
      if (e.code === "Digit4") setTool("window");
      if (e.code === "Digit5") setTool("room");
      if (e.code === "Digit6") setTool("furniture");
      if (e.code === "Digit7") setTool("dimension");
    }

    refreshUI();
  }

  function onKeyUp(e) {
    if (e.code === "Space") keys.space = false;
    keys.alt = e.altKey;
    keys.shift = e.shiftKey;
    keys.ctrl = e.ctrlKey || e.metaKey;
  }

  function copySelection() {
    const arr = selectedObjects().map(x => ({type:x.type, obj: deepCopy(x.obj)}));
    if (!arr.length) return;
    state.clipboard = arr;
    setStatus(`Скопировано: ${arr.length}`);
  }

  function pasteClipboard() {
    if (!state.clipboard || !state.clipboard.length) return;
    pushHistory();
    clearSelection();

    const offset = 20 / state.camera.z;
    const newIds = [];

    for (const it of state.clipboard) {
      const o = deepCopy(it.obj);
      o.id = uid();

      if (it.type === "furniture") { o.x += offset; o.y += offset; state.furniture.push(o); }
      if (it.type === "room") { o.pts = o.pts.map(p => ({x:p.x+offset, y:p.y+offset})); state.rooms.push(o); }
      if (it.type === "wall") { o.pts = o.pts.map(p => ({x:p.x+offset, y:p.y+offset})); state.walls.push(o); }
      if (it.type === "dim") { o.ax += offset; o.ay += offset; o.bx += offset; o.by += offset; state.dims.push(o); }
      if (it.type === "opening") { o.t = clamp(o.t + 0.02, 0, 1); state.openings.push(o); }

      newIds.push(o.id);
    }

    for (const id of newIds) state.selection.ids.add(id);
    state.selection.primary = newIds[0] || null;
    refreshUI();
  }

  function duplicateSelection() {
    copySelection();
    pasteClipboard();
  }

  // wheel: zoom, rotate furniture if selected and rotate mode
  function onWheel(e) {
    const delta = e.deltaY;
    const factor = keys.shift ? 1.12 : 1.08;

    if (state.interaction.rotateMode) {
      const p = getPrimaryObject();
      if (p && p.type === "furniture") {
        pushHistory();
        const step = keys.shift ? rad(15) : rad(5);
        p.obj.rot += (delta > 0 ? step : -step);
        refreshUI();
      }
      e.preventDefault();
      return;
    }

    const zoomIn = delta < 0;
    const oldZ = state.camera.z;
    const newZ = clamp(oldZ * (zoomIn ? factor : 1/factor), 0.2, 6);

    // zoom around mouse point
    const mx = mouse.x, my = mouse.y;
    const before = screenToWorld(mx,my);
    state.camera.z = newZ;
    const after = screenToWorld(mx,my);
    state.camera.x += (before.x - after.x);
    state.camera.y += (before.y - after.y);

    draw();
    e.preventDefault();
  }

  function fmtPoint(p) {
    const mx = p.x / state.pxPerM;
    const my = p.y / state.pxPerM;
    return `${(mx).toFixed(2)}м, ${(my).toFixed(2)}м`;
  }
  function fmtLen(px) {
    const m = px / state.pxPerM;
    return `${(m*100).toFixed(0)} см`;
  }

  // ---------- Buttons ----------
  toolButtons.forEach(b => b.addEventListener("click", () => setTool(b.dataset.tool)));

  undoBtn.addEventListener("click", undo);
  redoBtn.addEventListener("click", redo);
  delBtn.addEventListener("click", deleteSelection);
  clearBtn.addEventListener("click", clearAll);

  saveBtn.addEventListener("click", downloadJSON);
  loadBtn.addEventListener("click", () => loadFile.click());
  loadFile.addEventListener("change", async () => {
    const f = loadFile.files?.[0];
    if (!f) return;
    try {
      const text = await f.text();
      const obj = JSON.parse(text);
      importProject(obj);
      setStatus("Загружено");
    } catch {
      setStatus("Ошибка загрузки JSON");
    } finally {
      loadFile.value = "";
    }
  });

  exportBtn.addEventListener("click", exportPNG);

  snapGridEl.addEventListener("change", refreshUI);
  snapGeomEl.addEventListener("change", refreshUI);
  snapOrthoEl.addEventListener("change", refreshUI);
  showDimsEl.addEventListener("change", refreshUI);
  gridCmEl.addEventListener("input", refreshUI);
  pxPerMEl.addEventListener("input", refreshUI);

  // ---------- Events ----------
  canvas.addEventListener("mousemove", onMouseMove);
  canvas.addEventListener("mousedown", onMouseDown);
  window.addEventListener("mouseup", onMouseUp, {passive:true});
  canvas.addEventListener("wheel", onWheel, { passive: false });

  window.addEventListener("keydown", onKeyDown);
  window.addEventListener("keyup", onKeyUp);

  window.addEventListener("resize", () => draw());

  // ---------- Init ----------
  function init() {
    rebuildLibrary();
    rebuildLayersUI();

    // load autosave if present
    const ok = loadAutosave();
    if (!ok) {
      // small starter example
      state.camera.z = 1;
      state.camera.x = 0;
      state.camera.y = 0;

      pushHistory();
      state.walls.push({
        id: uid(),
        layerId:"walls",
        thicknessPx: 18,
        color:"#2f2f2f",
        pts: [{x:-240,y:-140},{x:240,y:-140},{x:240,y:140},{x:-240,y:140},{x:-240,y:-140}]
      });
      state.openings.push({
        id: uid(), layerId:"openings", type:"door",
        wallId: state.walls[0].id, segIndex: 0, t: 0.5,
        widthPx: 90, swing: 1, color:"#1f7a34"
      });
      state.rooms.push({
        id: uid(), layerId:"rooms",
        pts: [{x:-210,y:-110},{x:210,y:-110},{x:210,y:110},{x:-210,y:110}],
        fill:"#dfeff0", label:"Комната"
      });
    }

    refreshUI();
    setStatus("Готово");
  }

  init();
})();
