Option Explicit

' ====== НАСТРОЙКИ ======
Private Const TARGET_UNDERLINE_RGB As Long = vbRed   ' красный (RGB(255,0,0))
Private Const DICT_NAME As String = "RedUnderlinedWords.dic"

Public Sub AddRedUnderlinedWordsToDictionary()
    Dim wordApp As Object           ' Word.Application (late binding)
    Dim dictObj As Object           ' Word.Dictionary
    Dim dictPath As String

    On Error GoTo EH

    Set wordApp = GetOrCreateWordApp()
    dictPath = GetDefaultUProofFolder() & "\" & DICT_NAME
    Set dictObj = GetOrCreateDictionary(wordApp, dictPath)

    Dim sld As Slide, shp As Shape
    For Each sld In ActivePresentation.Slides
        For Each shp In sld.Shapes
            ProcessShapeText shp, dictObj
        Next shp
    Next sld

    ' Word обычно сохраняет словарь сам, но на всякий случай
    On Error Resume Next
    dictObj.Save
    On Error GoTo 0

    MsgBox "Готово. Слова с красным подчеркиванием добавлены в словарь:" & vbCrLf & dictPath, vbInformation
    Exit Sub

EH:
    MsgBox "Ошибка: " & Err.Number & vbCrLf & Err.Description, vbCritical
End Sub

' ====== ОБРАБОТКА ФИГУР ======
Private Sub ProcessShapeText(ByVal shp As Shape, ByVal dictObj As Object)
    On Error Resume Next

    ' Обычный текст
    If shp.HasTextFrame Then
        If shp.TextFrame.HasText Then
            ProcessTextRange shp.TextFrame.TextRange, dictObj
        End If
    End If

    ' Текст в таблицах
    If shp.HasTable Then
        Dim r As Long, c As Long
        For r = 1 To shp.Table.Rows.Count
            For c = 1 To shp.Table.Columns.Count
                ProcessTextRange shp.Table.Cell(r, c).Shape.TextFrame.TextRange, dictObj
            Next c
        Next r
    End If

    ' Группы
    If shp.Type = msoGroup Then
        Dim i As Long
        For i = 1 To shp.GroupItems.Count
            ProcessShapeText shp.GroupItems(i), dictObj
        Next i
    End If

    On Error GoTo 0
End Sub

Private Sub ProcessTextRange(ByVal tr As TextRange, ByVal dictObj As Object)
    Dim i As Long
    Dim run As TextRange
    Dim s As String

    If tr Is Nothing Then Exit Sub
    If tr.Length = 0 Then Exit Sub

    For i = 1 To tr.Runs.Count
        Set run = tr.Runs(i)

        If IsRedUnderlined(run) Then
            s = run.Text
            AddWordsFromStringToDict s, dictObj
        End If
    Next i
End Sub

Private Function IsRedUnderlined(ByVal run As TextRange) As Boolean
    On Error GoTo NOPE

    ' Учитываем разные типы подчеркивания (одинарное, двойное и тд)
    If run.Font.Underline <> msoFalse Then
        ' Проверка цвета именно подчеркивания (если доступно)
        If run.Font.UnderlineColor.RGB = TARGET_UNDERLINE_RGB Then
            IsRedUnderlined = True
            Exit Function
        End If

        ' На некоторых сборках UnderlineColor может быть недоступен или не совпадать.
        ' Тогда fallback: если цвет шрифта красный и есть подчеркивание.
        If run.Font.Color.RGB = TARGET_UNDERLINE_RGB Then
            IsRedUnderlined = True
            Exit Function
        End If
    End If

NOPE:
    IsRedUnderlined = False
End Function

' ====== ДОБАВЛЕНИЕ СЛОВ ======
Private Sub AddWordsFromStringToDict(ByVal text As String, ByVal dictObj As Object)
    Dim tokens() As String
    Dim t As Variant
    Dim w As String

    tokens = SplitToWordTokens(text)
    For Each t In tokens
        w = NormalizeWord(CStr(t))
        If Len(w) > 0 Then
            AddWordSafe dictObj, w
        End If
    Next t
End Sub

Private Sub AddWordSafe(ByVal dictObj As Object, ByVal w As String)
    On Error Resume Next
    ' Word.Dictionary имеет метод AddWord
    dictObj.AddWord w
    On Error GoTo 0
End Sub

Private Function SplitToWordTokens(ByVal s As String) As String()
    ' Делим по пробелам, табам и переносам, а чистку делаем отдельно
    Dim tmp As String
    tmp = Replace(s, vbCr, " ")
    tmp = Replace(tmp, vbLf, " ")
    tmp = Replace(tmp, vbTab, " ")
    SplitToWordTokens = Split(tmp, " ")
End Function

Private Function NormalizeWord(ByVal s As String) As String
    ' Удаляем пунктуацию по краям, оставляя дефисы и апострофы внутри
    Dim i As Long
    s = Trim$(s)
    If Len(s) = 0 Then Exit Function

    ' Убираем невидимые символы
    s = Replace(s, ChrW(160), " ") ' non-breaking space
    s = Trim$(s)

    ' Срезаем мусор слева
    Do While Len(s) > 0 And Not IsWordChar(Mid$(s, 1, 1))
        s = Mid$(s, 2)
    Loop

    ' Срезаем мусор справа
    Do While Len(s) > 0 And Not IsWordChar(Mid$(s, Len(s), 1))
        s = Left$(s, Len(s) - 1)
    Loop

    NormalizeWord = s
End Function

Private Function IsWordChar(ByVal ch As String) As Boolean
    ' Разрешаем буквы/цифры, а также дефис и апостроф
    Dim code As Long
    If Len(ch) = 0 Then Exit Function

    If ch = "-" Or ch = "'" Then
        IsWordChar = True
        Exit Function
    End If

    code = AscW(ch)

    ' 0-9
    If code >= 48 And code <= 57 Then IsWordChar = True: Exit Function

    ' A-Z a-z
    If (code >= 65 And code <= 90) Or (code >= 97 And code <= 122) Then IsWordChar = True: Exit Function

    ' А-Я а-я + Ёё
    If (code >= 1040 And code <= 1103) Or code = 1025 Or code = 1105 Then IsWordChar = True: Exit Function

    IsWordChar = False
End Function

' ====== WORD: СЛОВАРЬ ======
Private Function GetOrCreateWordApp() As Object
    On Error Resume Next
    Set GetOrCreateWordApp = GetObject(, "Word.Application")
    On Error GoTo 0

    If GetOrCreateWordApp Is Nothing Then
        Set GetOrCreateWordApp = CreateObject("Word.Application")
    End If
End Function

Private Function GetOrCreateDictionary(ByVal wordApp As Object, ByVal dictPath As String) As Object
    Dim dicts As Object
    Dim i As Long

    Set dicts = wordApp.CustomDictionaries

    ' Уже подключен?
    For i = 1 To dicts.Count
        If LCase$(dicts(i).Path) = LCase$(dictPath) Then
            Set GetOrCreateDictionary = dicts(i)
            Exit Function
        End If
    Next i

    ' Если файла нет - создаем пустой
    If Dir$(dictPath) = "" Then
        CreateEmptyFile dictPath
    End If

    ' Подключаем словарь
    Set GetOrCreateDictionary = dicts.Add(dictPath)
End Function

Private Sub CreateEmptyFile(ByVal path As String)
    Dim f As Integer
    EnsureFolderExists Left$(path, InStrRev(path, "\") - 1)
    f = FreeFile
    Open path For Output As #f
    Print #f, ""  ' пустая строка
    Close #f
End Sub

Private Sub EnsureFolderExists(ByVal folderPath As String)
    If Len(folderPath) = 0 Then Exit Sub
    If Dir$(folderPath, vbDirectory) = "" Then
        MkDir folderPath
    End If
End Sub

Private Function GetDefaultUProofFolder() As String
    ' Обычно: %AppData%\Microsoft\UProof
    GetDefaultUProofFolder = Environ$("APPDATA") & "\Microsoft\UProof"
End Function
